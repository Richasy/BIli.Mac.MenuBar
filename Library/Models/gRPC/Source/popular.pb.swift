// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bilibili/app/show/popular/v1/popular.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 热门列表-请求
struct Bilibili_App_Show_V1_PopularResultReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 排位索引id，为上此请求末尾项的idx
  var idx: Int64 {
    get {return _storage._idx}
    set {_uniqueStorage()._idx = newValue}
  }

  /// 登录标识
  /// 1:未登陆用户第一页 2:登陆用户第一页
  var loginEvent: Int32 {
    get {return _storage._loginEvent}
    set {_uniqueStorage()._loginEvent = newValue}
  }

  /// 清晰度(旧版)
  var qn: Int32 {
    get {return _storage._qn}
    set {_uniqueStorage()._qn = newValue}
  }

  /// 视频流版本(旧版)
  var fnver: Int32 {
    get {return _storage._fnver}
    set {_uniqueStorage()._fnver = newValue}
  }

  /// 视频流功能(旧版)
  var fnval: Int32 {
    get {return _storage._fnval}
    set {_uniqueStorage()._fnval = newValue}
  }

  /// 是否强制使用域名(旧版)
  var forceHost: Int32 {
    get {return _storage._forceHost}
    set {_uniqueStorage()._forceHost = newValue}
  }

  /// 是否4K(旧版)
  var fourk: Int32 {
    get {return _storage._fourk}
    set {_uniqueStorage()._fourk = newValue}
  }

  /// 当前页面spm
  var spmid: String {
    get {return _storage._spmid}
    set {_uniqueStorage()._spmid = newValue}
  }

  /// 上此请求末尾项的param
  var lastParam: String {
    get {return _storage._lastParam}
    set {_uniqueStorage()._lastParam = newValue}
  }

  /// 上此请求的ver
  var ver: String {
    get {return _storage._ver}
    set {_uniqueStorage()._ver = newValue}
  }

  /// 分品类热门的入口ID
  var entranceID: Int64 {
    get {return _storage._entranceID}
    set {_uniqueStorage()._entranceID = newValue}
  }

  /// 热门定位id集合
  var locationIds: String {
    get {return _storage._locationIds}
    set {_uniqueStorage()._locationIds = newValue}
  }

  /// 0:tag页 1:中间页
  var sourceID: Int32 {
    get {return _storage._sourceID}
    set {_uniqueStorage()._sourceID = newValue}
  }

  /// 数据埋点上报
  /// 0:代表手动刷新 1:代表自动刷新
  var flush: Int32 {
    get {return _storage._flush}
    set {_uniqueStorage()._flush = newValue}
  }

  /// 秒开参数
  var playerArgs: Bilibili_App_Archive_Middleware_V1_PlayerArgs {
    get {return _storage._playerArgs ?? Bilibili_App_Archive_Middleware_V1_PlayerArgs()}
    set {_uniqueStorage()._playerArgs = newValue}
  }
  /// Returns true if `playerArgs` has been explicitly set.
  var hasPlayerArgs: Bool {return _storage._playerArgs != nil}
  /// Clears the value of `playerArgs`. Subsequent reads from it will return its default value.
  mutating func clearPlayerArgs() {_uniqueStorage()._playerArgs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 热门列表-响应
struct Bilibili_App_Show_V1_PopularReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 卡片列表
  var items: [Bilibili_App_Card_V1_Card] = []

  /// 配置信息
  var config: Bilibili_App_Show_V1_Config {
    get {return _config ?? Bilibili_App_Show_V1_Config()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {self._config = nil}

  /// 版本
  var ver: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _config: Bilibili_App_Show_V1_Config? = nil
}

/// 配置信息
struct Bilibili_App_Show_V1_Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 标题
  var itemTitle: String = String()

  /// 底部文案
  var bottomText: String = String()

  /// 底部图片url
  var bottomTextCover: String = String()

  /// 底部跳转页url
  var bottomTextURL: String = String()

  /// 顶部按钮信息列表
  var topItems: [Bilibili_App_Show_V1_EntranceShow] = []

  /// 头图url
  var headImage: String = String()

  /// 当前页按钮信息
  var pageItems: [Bilibili_App_Show_V1_EntranceShow] = []

  var hit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 按钮信息
struct Bilibili_App_Show_V1_EntranceShow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 按钮图标url
  var icon: String = String()

  /// 按钮名
  var title: String = String()

  /// 入口模块id
  var moduleID: String = String()

  /// 跳转uri
  var uri: String = String()

  /// 气泡信息
  var bubble: Bilibili_App_Show_V1_Bubble {
    get {return _bubble ?? Bilibili_App_Show_V1_Bubble()}
    set {_bubble = newValue}
  }
  /// Returns true if `bubble` has been explicitly set.
  var hasBubble: Bool {return self._bubble != nil}
  /// Clears the value of `bubble`. Subsequent reads from it will return its default value.
  mutating func clearBubble() {self._bubble = nil}

  /// 入口id
  var entranceID: Int64 = 0

  /// 头图url
  var topPhoto: String = String()

  /// 入口类型
  var entranceType: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bubble: Bilibili_App_Show_V1_Bubble? = nil
}

/// 气泡信息
struct Bilibili_App_Show_V1_Bubble {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 文案
  var bubbleContent: String = String()

  /// 版本
  var version: Int32 = 0

  /// 起始时间
  var stime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Bilibili_App_Show_V1_PopularResultReq: @unchecked Sendable {}
extension Bilibili_App_Show_V1_PopularReply: @unchecked Sendable {}
extension Bilibili_App_Show_V1_Config: @unchecked Sendable {}
extension Bilibili_App_Show_V1_EntranceShow: @unchecked Sendable {}
extension Bilibili_App_Show_V1_Bubble: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bilibili.app.show.v1"

extension Bilibili_App_Show_V1_PopularResultReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PopularResultReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "idx"),
    2: .standard(proto: "login_event"),
    3: .same(proto: "qn"),
    4: .same(proto: "fnver"),
    5: .same(proto: "fnval"),
    6: .standard(proto: "force_host"),
    7: .same(proto: "fourk"),
    8: .same(proto: "spmid"),
    9: .standard(proto: "last_param"),
    10: .same(proto: "ver"),
    11: .standard(proto: "entrance_id"),
    12: .standard(proto: "location_ids"),
    13: .standard(proto: "source_id"),
    14: .same(proto: "flush"),
    15: .standard(proto: "player_args"),
  ]

  fileprivate class _StorageClass {
    var _idx: Int64 = 0
    var _loginEvent: Int32 = 0
    var _qn: Int32 = 0
    var _fnver: Int32 = 0
    var _fnval: Int32 = 0
    var _forceHost: Int32 = 0
    var _fourk: Int32 = 0
    var _spmid: String = String()
    var _lastParam: String = String()
    var _ver: String = String()
    var _entranceID: Int64 = 0
    var _locationIds: String = String()
    var _sourceID: Int32 = 0
    var _flush: Int32 = 0
    var _playerArgs: Bilibili_App_Archive_Middleware_V1_PlayerArgs? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _idx = source._idx
      _loginEvent = source._loginEvent
      _qn = source._qn
      _fnver = source._fnver
      _fnval = source._fnval
      _forceHost = source._forceHost
      _fourk = source._fourk
      _spmid = source._spmid
      _lastParam = source._lastParam
      _ver = source._ver
      _entranceID = source._entranceID
      _locationIds = source._locationIds
      _sourceID = source._sourceID
      _flush = source._flush
      _playerArgs = source._playerArgs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._idx) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._loginEvent) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._qn) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._fnver) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._fnval) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._forceHost) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._fourk) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._spmid) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._lastParam) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._ver) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._entranceID) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._locationIds) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._sourceID) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._flush) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._playerArgs) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._idx != 0 {
        try visitor.visitSingularInt64Field(value: _storage._idx, fieldNumber: 1)
      }
      if _storage._loginEvent != 0 {
        try visitor.visitSingularInt32Field(value: _storage._loginEvent, fieldNumber: 2)
      }
      if _storage._qn != 0 {
        try visitor.visitSingularInt32Field(value: _storage._qn, fieldNumber: 3)
      }
      if _storage._fnver != 0 {
        try visitor.visitSingularInt32Field(value: _storage._fnver, fieldNumber: 4)
      }
      if _storage._fnval != 0 {
        try visitor.visitSingularInt32Field(value: _storage._fnval, fieldNumber: 5)
      }
      if _storage._forceHost != 0 {
        try visitor.visitSingularInt32Field(value: _storage._forceHost, fieldNumber: 6)
      }
      if _storage._fourk != 0 {
        try visitor.visitSingularInt32Field(value: _storage._fourk, fieldNumber: 7)
      }
      if !_storage._spmid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._spmid, fieldNumber: 8)
      }
      if !_storage._lastParam.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastParam, fieldNumber: 9)
      }
      if !_storage._ver.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ver, fieldNumber: 10)
      }
      if _storage._entranceID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._entranceID, fieldNumber: 11)
      }
      if !_storage._locationIds.isEmpty {
        try visitor.visitSingularStringField(value: _storage._locationIds, fieldNumber: 12)
      }
      if _storage._sourceID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._sourceID, fieldNumber: 13)
      }
      if _storage._flush != 0 {
        try visitor.visitSingularInt32Field(value: _storage._flush, fieldNumber: 14)
      }
      try { if let v = _storage._playerArgs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bilibili_App_Show_V1_PopularResultReq, rhs: Bilibili_App_Show_V1_PopularResultReq) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._idx != rhs_storage._idx {return false}
        if _storage._loginEvent != rhs_storage._loginEvent {return false}
        if _storage._qn != rhs_storage._qn {return false}
        if _storage._fnver != rhs_storage._fnver {return false}
        if _storage._fnval != rhs_storage._fnval {return false}
        if _storage._forceHost != rhs_storage._forceHost {return false}
        if _storage._fourk != rhs_storage._fourk {return false}
        if _storage._spmid != rhs_storage._spmid {return false}
        if _storage._lastParam != rhs_storage._lastParam {return false}
        if _storage._ver != rhs_storage._ver {return false}
        if _storage._entranceID != rhs_storage._entranceID {return false}
        if _storage._locationIds != rhs_storage._locationIds {return false}
        if _storage._sourceID != rhs_storage._sourceID {return false}
        if _storage._flush != rhs_storage._flush {return false}
        if _storage._playerArgs != rhs_storage._playerArgs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bilibili_App_Show_V1_PopularReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PopularReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
    2: .same(proto: "config"),
    3: .same(proto: "ver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ver) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.ver.isEmpty {
      try visitor.visitSingularStringField(value: self.ver, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bilibili_App_Show_V1_PopularReply, rhs: Bilibili_App_Show_V1_PopularReply) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs._config != rhs._config {return false}
    if lhs.ver != rhs.ver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bilibili_App_Show_V1_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Config"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_title"),
    2: .standard(proto: "bottom_text"),
    3: .standard(proto: "bottom_text_cover"),
    4: .standard(proto: "bottom_text_url"),
    5: .standard(proto: "top_items"),
    6: .standard(proto: "head_image"),
    7: .standard(proto: "page_items"),
    8: .same(proto: "hit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.itemTitle) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bottomText) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bottomTextCover) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bottomTextURL) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.topItems) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.headImage) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.pageItems) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.hit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.itemTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.itemTitle, fieldNumber: 1)
    }
    if !self.bottomText.isEmpty {
      try visitor.visitSingularStringField(value: self.bottomText, fieldNumber: 2)
    }
    if !self.bottomTextCover.isEmpty {
      try visitor.visitSingularStringField(value: self.bottomTextCover, fieldNumber: 3)
    }
    if !self.bottomTextURL.isEmpty {
      try visitor.visitSingularStringField(value: self.bottomTextURL, fieldNumber: 4)
    }
    if !self.topItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topItems, fieldNumber: 5)
    }
    if !self.headImage.isEmpty {
      try visitor.visitSingularStringField(value: self.headImage, fieldNumber: 6)
    }
    if !self.pageItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pageItems, fieldNumber: 7)
    }
    if self.hit != 0 {
      try visitor.visitSingularInt32Field(value: self.hit, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bilibili_App_Show_V1_Config, rhs: Bilibili_App_Show_V1_Config) -> Bool {
    if lhs.itemTitle != rhs.itemTitle {return false}
    if lhs.bottomText != rhs.bottomText {return false}
    if lhs.bottomTextCover != rhs.bottomTextCover {return false}
    if lhs.bottomTextURL != rhs.bottomTextURL {return false}
    if lhs.topItems != rhs.topItems {return false}
    if lhs.headImage != rhs.headImage {return false}
    if lhs.pageItems != rhs.pageItems {return false}
    if lhs.hit != rhs.hit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bilibili_App_Show_V1_EntranceShow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntranceShow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "icon"),
    2: .same(proto: "title"),
    3: .standard(proto: "module_id"),
    4: .same(proto: "uri"),
    5: .same(proto: "bubble"),
    6: .standard(proto: "entrance_id"),
    7: .standard(proto: "top_photo"),
    8: .standard(proto: "entrance_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._bubble) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.entranceID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.topPhoto) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.entranceType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 3)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 4)
    }
    try { if let v = self._bubble {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.entranceID != 0 {
      try visitor.visitSingularInt64Field(value: self.entranceID, fieldNumber: 6)
    }
    if !self.topPhoto.isEmpty {
      try visitor.visitSingularStringField(value: self.topPhoto, fieldNumber: 7)
    }
    if self.entranceType != 0 {
      try visitor.visitSingularInt32Field(value: self.entranceType, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bilibili_App_Show_V1_EntranceShow, rhs: Bilibili_App_Show_V1_EntranceShow) -> Bool {
    if lhs.icon != rhs.icon {return false}
    if lhs.title != rhs.title {return false}
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs._bubble != rhs._bubble {return false}
    if lhs.entranceID != rhs.entranceID {return false}
    if lhs.topPhoto != rhs.topPhoto {return false}
    if lhs.entranceType != rhs.entranceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bilibili_App_Show_V1_Bubble: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Bubble"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bubble_content"),
    2: .same(proto: "version"),
    3: .same(proto: "stime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bubbleContent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.stime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bubbleContent.isEmpty {
      try visitor.visitSingularStringField(value: self.bubbleContent, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    if self.stime != 0 {
      try visitor.visitSingularInt64Field(value: self.stime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bilibili_App_Show_V1_Bubble, rhs: Bilibili_App_Show_V1_Bubble) -> Bool {
    if lhs.bubbleContent != rhs.bubbleContent {return false}
    if lhs.version != rhs.version {return false}
    if lhs.stime != rhs.stime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
